# Руководство по socet api

Оригинал гайда - [ссылка](https://realpython.com/python-sockets/)

## История

Socket\`ы имеют долгую историю. Их использование началось с ARPANET в 1971 году и позже стало API в операционной системе Berkeley Software Distribution \(BSD\), выпущенной в 1983 году, называемой Berkeley sockets.

## Обзор Socket API

Модуль сокетов Python предоставляет интерфейс для API сокетов Беркли.

Основные функции и методы API сокетов в этом модуле:

* socket\(\)
* bind\(\)
* listen\(\)
* accept\(\)
* connect\(\)
* connect\_ex\(\)
* send\(\)
* recv\(\)
* close\(\)

Python предоставляет удобный и согласованный API, который отображается непосредственно на эти системные вызовы, их аналоги на языке C.

Как часть своей стандартной библиотеки, Python также имеет классы, которые облегчают использование этих низкоуровневых функций сокетов. Модуль socketserver , среду для сетевых серверов. Есть также много доступных модулей, которые реализуют высокоуровневые интернет-протоколы, такие как HTTP и SMTP.

## TCP Sockets

создадим объект сокета с помощью socket.socket\(\)и определим тип сокета как socket.SOCK\_STREAM. Когда вы делаете это, по умолчанию используется Transmission Control Protocol \(TCP\). Это хороший вариант по умолчанию.

Почему вы должны использовать TCP? Протокол управления передачей \(TCP\):

* Надежен: пакеты, отброшенные в сети, обнаруживаются и повторно передаются отправителем.
* Имеет порядок доставки данных: данные читаются вашим приложением в том порядке, в котором они были написаны отправителем.

Напротив, сокеты User Datagram Protocol \(UDP\), созданные с помощью socket.SOCK\_DGRAM, не являются надежными, и данные, считываемые получателем, могут быть не в порядке из записей отправителя.

Почему это важно? Сети - это система доставки с максимальными усилиями. Нет никакой гарантии, что ваши данные достигнут пункта назначения или вы получите то, что было отправлено вам.

Сетевые устройства \(например, маршрутизаторы и коммутаторы\) имеют ограниченную доступную полосу пропускания и собственные системные ограничения. Они имеют процессоры, память, шины и интерфейсные буферы пакетов, как наши клиенты и серверы. TCP избавляет вас от необходимости беспокоиться о потере пакетов , поступлении данных не по порядку и многим другим вещам, которые неизменно происходят при обмене данными по сети.

На диаграмме ниже давайте рассмотрим последовательность вызовов API сокетов и поток данных для TCP:

![TCP Socket Flow](https://upload.wikimedia.org/wikipedia/commons/a/a1/InternetSocketBasicDiagram_zhtw.png)

Обратите внимание на API-вызовы, которые сервер делает для настройки «слушающего» сокета:

* socket\(\)
* bind\(\)
* listen\(\)
* accept\(\)

Разъем для прослушивания listen\(\) делает то, на что это похоже. Он слушает соединения от клиентов. Когда клиент подключается, сервер вызывает, accept\(\) чтобы принять или завершить соединение.

Клиент звонит, connect\(\) чтобы установить соединение с сервером и инициировать трехстороннее рукопожатие. Этап рукопожатия важен, поскольку он гарантирует, что каждая сторона соединения достижима в сети, другими словами, что клиент может достичь сервера и наоборот. Может случиться так, что только один хост, клиент или сервер может связаться с другим.

В середине находится раздел «туда-обратно», где данные обмениваются между клиентом и сервером с использованием вызовов send\(\)и recv\(\).

Внизу клиент и сервер закрывает close\(\) их соответствующий сокет.

## Echo Client and Server

Теперь, когда вы увидели обзор API сокетов и взаимодействия клиента и сервера, давайте создадим наш первый клиент и сервер. Начнем с простой реализации. Сервер просто отобразит все, что получит обратно клиенту.

### Echo Server

Вот сервер echo-server.py:

```text
#!/usr/bin/env python3

import socket

HOST = '127.0.0.1'  # Standard loopback interface address (localhost)
PORT = 65432        # Port to listen on (non-privileged ports are > 1023)

with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.bind((HOST, PORT))
    s.listen()
    conn, addr = s.accept()
    with conn:
        print('Connected by', addr)
        while True:
            data = conn.recv(1024)
            if not data:
                break
            conn.sendall(data)
```

Давайте рассмотрим каждый вызов API и посмотрим, что происходит.

socket.socket\(\)создает объект сокета, который поддерживает тип менеджера контекста , так что вы можете использовать его в with выражении . Там нет необходимости звонить s.close\(\):

```text
with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    pass  # Use the socket object without calling s.close().
```

Передаваемые аргументы socket\(\)указывают семейство адресов и тип сокета. AF\_INET это семейство интернет-адресов для IPv4 . SOCK\_STREAM это тип сокета для TCP, протокола, который будет использоваться для передачи наших сообщений в сети.

bind\(\) используется для связи сокета с определенным сетевым интерфейсом и номером порта:

```text
HOST = '127.0.0.1'  # Standard loopback interface address (localhost)
PORT = 65432        # Port to listen on (non-privileged ports are > 1023)

# ...

s.bind((HOST, PORT))
```

Передаваемые значения bind\(\)зависят от семейства адресов сокета. В этом примере мы используем socket.AF\_INET\(IPv4\). Так что ожидается 2 кортежа \(host, port\).

host может быть именем хоста, IP-адресом или пустой строкой. Если используется IP-адрес, host должна быть строка адреса в формате IPv4. IP-адрес 127.0.0.1 является стандартным адресом IPv4 для интерфейса обратной связи, поэтому только процессы на хосте смогут подключаться к серверу. Если вы передадите пустую строку, сервер примет соединения на всех доступных интерфейсах IPv4.

port должн быть целым числом от 1- 65535 \(0 зарезервировано\). Это номер порта TCP для приема подключений от клиентов. Некоторые системы могут требовать привилегий суперпользователя, если порт &lt; 1024.

Вот примечание об использовании имен хостов с bind\(\):

> «Если вы используете имя хоста в части хоста адреса сокета IPv4 / v6, программа может показывать недетерминированное поведение, так как Python использует первый адрес, возвращенный из разрешения DNS. Адрес сокета будет преобразован по-разному в фактический адрес IPv4 / v6, в зависимости от результатов разрешения DNS и / или конфигурации хоста. Для детерминированного поведения используйте числовой адрес в части хоста».

При использовании имени хоста вы можете увидеть разные результаты в зависимости от того, что возвращается из процесса разрешения имен.

Это может быть что угодно. При первом запуске приложения это может быть адрес 10.1.2.3. В следующий раз это другой адрес 192.168.0.1. В третий раз это может быть 172.16.7.8 и так далее.

Продолжая пример с сервером, listen\(\) позволяет серверу accept\(\) подключаться. Это делает его «слушающим» сокетом:

```text
s.listen()
conn, addr = s.accept()
```

listen\(\)имеет backlog параметр. Он указывает количество неприемлемых соединений, которые система разрешит перед отказом в новых соединениях. Начиная с Python 3.5, это необязательно. Если не указан, backlog выбирается значение по умолчанию.

Если ваш сервер получает много запросов на соединение одновременно, увеличение backlogзначения может помочь, установив максимальную длину очереди для ожидающих соединений. Максимальное значение зависит от системы. Например, в Linux см /proc/sys/net/core/somaxconn.

accept\(\) блокирует и ждет входящего соединения. Когда клиент подключается, он возвращает новый объект сокета, представляющий соединение, и кортеж, содержащий адрес клиента. Кортеж будет содержать \(host, port\)соединения IPv4 или \(host, port, flowinfo, scopeid\)IPv6.

Одна вещь, которую необходимо понять, это то, что у нас теперь есть новый объект сокета accept\(\). Это важно, так как это сокет, который вы будете использовать для связи с клиентом. Он отличается от сокета прослушивания, который сервер использует для приема новых соединений:

```text
conn, addr = s.accept()
with conn:
    print('Connected by', addr)
    while True:
        data = conn.recv(1024)
        if not data:
            break
        conn.sendall(data)
```

После того , как объект сокета клиента conn из accept\(\), бесконечный while цикла используются для перебора блокирующих вызовов к conn.recv\(\). Это читает любые данные, которые клиент отправляет, и возвращает их обратно, используя conn.sendall\(\).

Если conn.recv\(\) возвращает пустой bytes объект, b''то клиент закрыл соединение и цикл прерывается. Оператор with использует conn для автоматического закрытия сокета в конце блока.

### Echo Client

Теперь давайте посмотрим на клиента echo-client.py:

```text
#!/usr/bin/env python3

import socket

HOST = '127.0.0.1'  # The server's hostname or IP address
PORT = 65432        # The port used by the server

with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.connect((HOST, PORT))
    s.sendall(b'Hello, world')
    data = s.recv(1024)

print('Received', repr(data))
```

По сравнению с сервером клиент довольно прост. Он создает объект сокета, подключается к серверу и вызывает s.sendall\(\) для отправки своего сообщения. Наконец, он вызывает s.recv\(\) чтение ответа сервера, а затем печатает его.

## Запуск клиента и сервера Echo

Давайте запустим клиент и сервер, чтобы посмотреть, как они себя ведут, и проверить, что происходит.

Откройте терминал или командную строку, перейдите в каталог, содержащий ваши сценарии, и запустите сервер:

```text
$ ./echo-server.py
```

Ваш терминал будет зависать. Это потому, что сервер заблокирован \(приостановлен\) при вызове:

```text
conn, addr = s.accept()
```

Он ждет подключения клиента. Теперь откройте другое окно терминала или командную строку и запустите клиент:

```text
$ ./echo-client.py 
Received b'Hello, world'
```

В окне сервера вы должны увидеть:

```text
$ ./echo-server.py 
Connected by ('127.0.0.1', 64623)
```

В приведенном выше выводе сервер напечатал addr кортеж, возвращенный из s.accept\(\). Это IP-адрес клиента и номер порта TCP. Номер порта, 64623 скорее всего, будет другим, когда вы запустите его на своей машине.

### Просмотр состояния сокета

Чтобы увидеть текущее состояние сокетов на вашем хосте, используйте netstat. Он доступен по умолчанию в macOS, Linux и Windows.

Вот вывод netstat из macOS после запуска сервера:

```text
$ netstat -an
Active Internet connections (including servers)
Proto Recv-Q Send-Q  Local Address          Foreign Address        (state)
tcp4       0      0  127.0.0.1.65432        *.*                    LISTEN
```

Обратите внимание, что Local Addressэто так 127.0.0.1.65432. Если echo-server.pyбы HOST = ''вместо этого HOST = '127.0.0.1', netstat показал бы это:

```text
$ netstat -an
Active Internet connections (including servers)
Proto Recv-Q Send-Q  Local Address          Foreign Address        (state)
tcp4       0      0  *.65432                *.*                    LISTEN
```

Local Addressis \*.65432, что означает, что все доступные интерфейсы хоста, которые поддерживают семейство адресов, будут использоваться для приема входящих соединений. В этом примере, в вызове socket\(\), socket.AF\_INETбыл использован \(IPv4\). Вы можете увидеть это в Protoколонке: tcp4.

Я обрезал вывод выше, чтобы показать только эхо-сервер. Скорее всего, вы увидите гораздо больший вывод, в зависимости от того, на какой системе он запущен. То , что в уведомлении являются столбцы Proto, Local Addressи \(state\). В последнем приведенном выше примере netstat показывает, что эхо-сервер использует TCP-сокет IPv4 \( tcp4\), на порту 65432 на всех интерфейсах \( \*.65432\) и находится в состоянии прослушивания \( LISTEN\).

Другой способ увидеть это, наряду с дополнительной полезной информацией, - использовать lsof\(перечислить открытые файлы\). Он доступен по умолчанию в macOS и может быть установлен в Linux с помощью диспетчера пакетов, если это еще не сделано:

```text
lsof -i -n
COMMAND     PID   USER   FD   TYPE   DEVICE SIZE/OFF NODE NAME
Python    67982 nathan    3u  IPv4 0xecf272      0t0  TCP *:65432 (LISTEN)
```

lsof выдает COMMAND, PID\(идентификатор процесса\) и USER\(идентификатор пользователя\) открытых интернет-сокетов при использовании с -i опцией. Выше эхо-серверный процесс.

netstat и lsof иметь много доступных опций и различаться в зависимости от ОС, на которой вы их используете. Проверьте man страницу или документацию для обоих. Им определенно стоит потратить немного времени и познакомиться. Вы будете вознаграждены. В macOS и Linux используйте man netstat и man lsof. Для Windows используйте netstat /?.

Вот типичная ошибка, которую вы увидите, когда будет предпринята попытка подключения к порту без прослушивающего сокета:

```text
$ ./echo-client.py 
Traceback (most recent call last):
  File "./echo-client.py", line 9, in <module>
    s.connect((HOST, PORT))
ConnectionRefusedError: [Errno 61] Connection refused
```

Либо указанный номер порта неверен, либо сервер не работает. Или, возможно, в пути есть брандмауэр, который блокирует соединение, о котором легко забыть. Вы также можете увидеть ошибку Connection timed out. Добавьте правило брандмауэра, которое позволяет клиенту подключаться к порту TCP!

### Отсутствие взаимопонимания

Давайте подробнее рассмотрим, как клиент и сервер общались друг с другом: ![](https://files.realpython.com/media/sockets-loopback-interface.44fa30c53c70.jpg) При использовании интерфейса обратной связи \(IPv4-адрес 127.0.0.1или IPv6-адрес ::1\) данные никогда не покидают хост и не касаются внешней сети. На приведенной выше схеме петлевой интерфейс находится внутри хоста. Это представляет внутреннюю природу интерфейса обратной связи и то, что соединения и данные, которые передают его, являются локальными для хоста. Вот почему вы также услышите петлевой интерфейс и IP-адрес 127.0.0.1или ::1именуете «localhost».

Приложения используют интерфейс обратной связи для связи с другими процессами, запущенными на хосте, а также для обеспечения безопасности и изоляции от внешней сети. Поскольку он внутренний и доступен только изнутри хоста, он не выставляется.

Вы можете увидеть это в действии, если у вас есть сервер приложений, который использует свою собственную частную базу данных. Если это не база данных, используемая другими серверами, возможно, она настроена на прослушивание соединений только через интерфейс обратной связи. В этом случае другие хосты в сети не могут подключиться к нему.

Когда вы используете IP-адрес, отличный от 127.0.0.1или ::1в ваших приложениях, он, вероятно, связан с интерфейсом Ethernet, который подключен к внешней сети. Это ваши ворота к другим хостам за пределами вашего «локального» королевства: ![](https://files.realpython.com/media/sockets-ethernet-interface.aac312541af5.jpg)

### Обработка нескольких соединений

Эхо-сервер определенно имеет свои ограничения. Самое большое, что он обслуживает только одного клиента и затем выходит. У эхо-клиента тоже есть это ограничение, но есть дополнительная проблема. Когда клиент выполняет следующий вызов, возможно, s.recv\(\)он вернет только один байт b'H'из b'Hello, world':

```text
data = s.recv(1024)
```

bufsize аргумент 1024 используется выше, максимальное количество данных , которые должны быть получены одновременно. Это не значит, что recv\(\)вернет 1024 байты.

send\(\)также ведет себя так. send\(\)возвращает количество отправленных байтов, которое может быть меньше размера передаваемых данных. Вы отвечаете за проверку и вызов send\(\)столько раз, сколько необходимо для отправки всех данных:

> «Заявки несут ответственность за проверку того, что все данные были отправлены; если были переданы только некоторые данные, приложению необходимо попытаться доставить оставшиеся данные». Мы избежали необходимости делать это, используя sendall\(\): «В отличие от send \(\), этот метод продолжает отправлять данные из байтов до тех пор, пока не будут отправлены все данные или пока не произойдет ошибка. Никто не возвращается в случае успеха».

На данный момент у нас есть две проблемы

* Как мы обрабатываем несколько соединений одновременно?
* Нам нужно позвонить send\(\)и recv\(\)до тех пор, пока все данные не будут отправлены или получены.

Что мы делаем? Есть много подходов к параллелизму . В последнее время популярным подходом является использование асинхронного ввода-вывода. asyncio был введен в стандартную библиотеку в Python 3.4.

Проблема с параллелизмом состоит в том, что трудно понять правильно. Есть много тонкостей, которые нужно учитывать и оберегать. Все, что требуется для того, чтобы один из них проявил себя, и ваше приложение может внезапно выйти из строя не очень тонкими способами.

Я не говорю это, чтобы отпугнуть вас от обучения и использования параллельного программирования. Если ваше приложение должно масштабироваться, это необходимо, если вы хотите использовать более одного процессора или одно ядро. Тем не менее, в этом уроке мы будем использовать нечто более традиционное, чем потоки, и о котором будет легче думать. Мы будем использовать дедуля системных вызовов: select\(\).

select\(\)позволяет проверять завершение ввода / вывода в нескольких сокетах. Таким образом, вы можете позвонить, select\(\)чтобы узнать, какие сокеты имеют ввод / вывод, готовый для чтения и / или записи. Но это Python, так что это еще не все. Мы собираемся использовать модуль селекторов в стандартной библиотеке, поэтому используется наиболее эффективная реализация, независимо от операционной системы, на которой мы работаем:

> «Этот модуль обеспечивает высокоуровневое и эффективное мультиплексирование ввода / вывода, построенное на примитивах выбранного модуля. Пользователям рекомендуется использовать этот модуль, если они не хотят точного контроля над используемыми примитивами уровня ОС».

Несмотря на то, что при использовании select\(\)мы не можем работать одновременно, в зависимости от вашей рабочей нагрузки, этот подход может быть достаточно быстрым. Это зависит от того, что вашему приложению нужно делать, когда оно обслуживает запрос, и от количества клиентов, которых оно должно поддерживать.

asyncioиспользует однопотоковую кооперативную многозадачность и цикл обработки событий для управления задачами. С помощью select\(\)мы напишем нашу собственную версию цикла событий, хотя и более просто и синхронно. При использовании нескольких потоков, даже если у вас есть параллелизм, в настоящее время мы должны использовать GIL с CPython и PyPy . Это эффективно ограничивает объем работы, которую мы можем выполнять параллельно.

Я говорю все это, чтобы объяснить, что использование select\(\)может быть прекрасным выбором. Не думайте, что вам нужно использовать asyncioпотоки или последнюю асинхронную библиотеку. Как правило, в сетевом приложении ваше приложение связано с вводом / выводом: оно может ожидать в локальной сети, конечных точках на другой стороне сети, на диске и т. Д.

Если вы получаете запросы от клиентов, которые инициируют работу с привязкой к процессору, посмотрите на модуль concurrent.futures . Он содержит класс ProcessPoolExecutor, который использует пул процессов для асинхронного выполнения вызовов.

Если вы используете несколько процессов, операционная система может запланировать параллельный запуск кода Python на нескольких процессорах или ядрах без GIL. За идеями и вдохновением обращайтесь к докладу PyCon Джона Риза - Мышление вне GIL с AsyncIO и мультипроцессором - PyCon 2018,

В следующем разделе мы рассмотрим примеры сервера и клиента, которые решают эти проблемы. Они используют select\(\)для обработки нескольких соединений одновременно и вызова send\(\)и recv\(\)столько раз, сколько необходимо.

## Многоканальный клиент и сервер

### Multi-Connection Server

Во-первых, давайте посмотрим на сервер мульти-соединения multiconn-server.py. Вот первая часть, которая устанавливает сокет прослушивания:

```text
import selectors
sel = selectors.DefaultSelector()
# ...
lsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
lsock.bind((host, port))
lsock.listen()
print('listening on', (host, port))
lsock.setblocking(False)
sel.register(lsock, selectors.EVENT_READ, data=None)
```

Самое большое различие между этим сервером и эхо-сервером - это призыв lsock.setblocking\(False\)настроить сокет в неблокирующем режиме. Звонки на этот сокет больше не будут блокироваться . Когда он используется с sel.select\(\), как вы увидите ниже, мы можем ожидать события на одном или нескольких сокетах, а затем читать и записывать данные, когда они будут готовы.

sel.register\(\)Регистры сокет будет контролироваться sel.select\(\)для событий вы заинтересованы в Для сокета, мы хотим прочитать события.: selectors.EVENT\_READ.

dataиспользуется для хранения любых произвольных данных вместе с сокетом. Он возвращается, когда select\(\)возвращается. Мы будем использовать dataдля отслеживания того, что было отправлено и получено в сокете.

Далее идет цикл событий:

```text
import selectors
sel = selectors.DefaultSelector()

# ...

while True:
    events = sel.select(timeout=None)
    for key, mask in events:
        if key.data is None:
            accept_wrapper(key.fileobj)
        else:
            service_connection(key, mask)
```

sel.select\(timeout=None\) блоки, пока нет готовых разъемов для ввода / вывода. Он возвращает список \(ключ, события\) кортежей, по одному на каждый сокет. keyявляется SelectorKey, namedtuple который содержит fileobjатрибут. key.fileobjявляется объектом сокета и maskявляется маской события готовых операций.

Если key.dataесть None, то мы знаем, что это из сокета прослушивания, и нам нужно accept\(\)соединение. Мы вызовем нашу собственную accept\(\)функцию-обертку, чтобы получить новый объект сокета и зарегистрировать его с помощью селектора.

Если key.dataнет None, то мы знаем, что это клиентский сокет, который уже принят, и нам нужно его обслужить. service\_connection\(\)затем вызывается и передается keyи mask, который содержит все, что нам нужно для работы с сокетом.

Давайте посмотрим, что accept\_wrapper\(\)делает наша функция:

```text
def accept_wrapper(sock):
    conn, addr = sock.accept()  # Should be ready to read
    print('accepted connection from', addr)
    conn.setblocking(False)
    data = types.SimpleNamespace(addr=addr, inb=b'', outb=b'')
    events = selectors.EVENT_READ | selectors.EVENT_WRITE
    sel.register(conn, events, data=data)
```

Поскольку прослушивающий сокет был зарегистрирован для события selectors.EVENT\_READ, он должен быть готов к чтению. Мы вызываем, sock.accept\(\)а затем немедленно вызываем, conn.setblocking\(False\)чтобы перевести сокет в неблокирующий режим. Помните, что это главная цель в этой версии сервера, так как мы не хотим, чтобы он блокировался . Если он блокируется, то весь сервер останавливается, пока не вернется. Это означает, что другие сокеты остаются в ожидании. Это ужасное состояние «зависания», когда вы не хотите, чтобы ваш сервер был включен.

Затем мы создаем объект для хранения данных, которые мы хотим включить вместе с сокетом, используя класс types.SimpleNamespace. Поскольку мы хотим знать, когда клиентское соединение готово для чтения и записи, оба эти события устанавливаются с помощью следующего:

```text
events = selectors.EVENT_READ | selectors.EVENT_WRITE
```

В eventsмаске, сокет, и объекты данных затем передаются sel.register\(\).

Теперь давайте посмотрим, service\_connection\(\) как обрабатывается клиентское соединение, когда оно готово:

```text
def service_connection(key, mask):
    sock = key.fileobj
    data = key.data
    if mask & selectors.EVENT_READ:
        recv_data = sock.recv(1024)  # Should be ready to read
        if recv_data:
            data.outb += recv_data
        else:
            print('closing connection to', data.addr)
            sel.unregister(sock)
            sock.close()
    if mask & selectors.EVENT_WRITE:
        if data.outb:
            print('echoing', repr(data.outb), 'to', data.addr)
            sent = sock.send(data.outb)  # Should be ready to write
            data.outb = data.outb[sent:]
```

Это сердце простого сервера мультисвязи. keyэто namedtupleвозвращается из select\(\)который содержит объект сокета \( fileobj\) и объект данных. maskсодержит события, которые готовы.

Если сокет готов к чтению, тогда он mask & selectors.EVENT\_READравен true и sock.recv\(\)вызывается. Любые прочитанные данные добавляются, data.outbчтобы их можно было отправить позже.

Обратите внимание на else:блок, если данные не получены:

```text
if recv_data:
    data.outb += recv_data
else:
    print('closing connection to', data.addr)
    sel.unregister(sock)
    sock.close()
```

Это означает, что клиент закрыл свой сокет, так что сервер тоже должен. Но не забудьте сначала позвонить, sel.unregister\(\)чтобы он больше не контролировался select\(\).

Когда сокет готов к записи, что всегда должно быть в случае исправного сокета, любые полученные данные, хранящиеся в нем data.outb, передаются клиенту с помощью sock.send\(\). Отправленные байты затем удаляются из буфера отправки:

```text
data.outb = data.outb[sent:]
```

Multi-Connection Client

Теперь давайте посмотрим на клиента мульти-соединения multiconn-client.py. Он очень похож на сервер, но вместо того, чтобы прослушивать соединения, он начинается с инициализации соединений через start\_connections\(\):

```text
messages = [b'Message 1 from client.', b'Message 2 from client.']


def start_connections(host, port, num_conns):
    server_addr = (host, port)
    for i in range(0, num_conns):
        connid = i + 1
        print('starting connection', connid, 'to', server_addr)
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.setblocking(False)
        sock.connect_ex(server_addr)
        events = selectors.EVENT_READ | selectors.EVENT_WRITE
        data = types.SimpleNamespace(connid=connid,
                                     msg_total=sum(len(m) for m in messages),
                                     recv_total=0,
                                     messages=list(messages),
                                     outb=b'')
        sel.register(sock, events, data=data)
```

num\_connsчитается из командной строки, которая представляет собой количество соединений, которые нужно создать с сервером. Как и сервер, каждый сокет установлен в неблокирующий режим.

connect\_ex\(\)используется вместо, connect\(\)поскольку connect\(\)сразу вызовет BlockingIOErrorисключение. connect\_ex\(\)первоначально возвращает индикатор ошибки errno.EINPROGRESS, вместо того, чтобы вызывать исключение во время соединения. Как только соединение завершено, сокет готов к чтению и записи и возвращается как таковой select\(\).

После установки сокета данные, которые мы хотим сохранить в сокете, создаются с использованием класса types.SimpleNamespace. Сообщения, которые клиент отправит на сервер, будут скопированы, list\(messages\)поскольку каждое соединение будет вызывать socket.send\(\)и изменять список. Все, что необходимо для отслеживания того, что клиент должен отправить, отправил и получил, а общее количество байтов в сообщениях хранится в объекте data.

Давайте посмотрим на service\_connection\(\). Это в основном так же, как сервер:

```text
    sock = key.fileobj
    data = key.data
    if mask & selectors.EVENT_READ:
        recv_data = sock.recv(1024)  # Should be ready to read
        if recv_data:
            print('received', repr(recv_data), 'from connection', data.connid)
            data.recv_total += len(recv_data)
        if not recv_data or data.recv_total == data.msg_total:
            print('closing connection', data.connid)
            sel.unregister(sock)
            sock.close()
    if mask & selectors.EVENT_WRITE:
        if not data.outb and data.messages:
            data.outb = data.messages.pop(0)
        if data.outb:
            print('sending', repr(data.outb), 'to connection', data.connid)
            sent = sock.send(data.outb)  # Should be ready to write
            data.outb = data.outb[sent:]
```

Есть одно важное отличие. Он отслеживает количество байтов, полученных от сервера, чтобы он мог закрыть свою сторону соединения. Когда сервер обнаруживает это, он также закрывает свою сторону соединения.

Обратите внимание, что при этом сервер зависит от хорошего поведения клиента: сервер ожидает, что клиент закроет свою сторону соединения после завершения отправки сообщений. Если клиент не закрывается, сервер оставит соединение открытым. В реальном приложении вы можете принять меры против этого на своем сервере и предотвратить накопление клиентских подключений, если они не отправляют запрос через определенное время.

